% Generated by roxygen2: do not edit by hand
% Please edit documentation in ./<text>
\name{rip.dft}
\alias{rip.dft}
\alias{rip.dct}
\title{DFT and DCT using OpenCV}
\usage{
rip.dft(x, pad = NULL,
        inverse = FALSE,
        scale = inverse,
        rowwise = FALSE,
        complex = TRUE,
        nonzerorows = 0)
rip.dct(x, pad = NULL, inverse = FALSE, rowwise = FALSE)
rip.ndft(x, pad = NULL, inverse = FALSE)
rip.ndct(x, pad = NULL, inverse = FALSE)
}
\arguments{

  \item{x}{\code{"'rip"} object to transform}

  \item{inverse}{Logical flag. If \code{TRUE}, inverse DFT is computed,
    assuming real output.}

  \item{scale}{Logical flag. If \code{TRUE}, divides transformed
    values by number of elements.}

  \item{rowwise}{Logical flag. If \code{TRUE}, computes DFT or DCT
    rowwise.}

  \item{complex}{Logical flag. If \code{TRUE}, stores output as complex
    numbers, otherwise imaginary part is stored in subdiagonal
    exploiting symmetry. Ignored when \code{inverse=TRUE}, in which case
    it is inferred from the input.  }

  \item{nonzerorows}{Integer. Assumes that only first nonzerorows have
    non-zero data. When 'inverse=TRUE', only first nonzerorows rows in
    the output will have non-zero data.}

}

\value{

  A \code{"rip"} object containing the transformed data. In the case of
  DFT, complex values are stored using the R-native complex type, and
  converted to the native 2-channel OpenCV representation as needed.

}

\description{

  Apply the Dicrete Fourier Transform (DFT) or the Discrete Cosine
  Transform (DCT) to a matrix.

}
\details{

  User-friendly interface to the OpenCV \code{cv::dft} and
  \code{cv::dct} functions via the \code{rip.cv$transforms} module.
  
} 

\examples{

n <- 100
x <- matrix(rnorm(n*n), n, n)
(F <- rip.dft(x))
(C <- rip.dct(x))
mean(F)
mean(Mod(F)^2)
mean(C^2)
mean(Mod(rip.ndft(x))^2)

}
